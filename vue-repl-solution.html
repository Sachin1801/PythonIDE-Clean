<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Web REPL - Complete Solution</title>
    
    <!-- Vue 3 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    
    <!-- Prism.js for syntax highlighting in output -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }

        .repl-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #252526;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .repl-header {
            background: #2d2d30;
            padding: 15px 20px;
            border-bottom: 1px solid #3e3e42;
        }

        .repl-header h2 {
            color: #569cd6;
            font-size: 18px;
            font-weight: 500;
        }

        /* REPL History Styles */
        .repl-history {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: #1e1e1e;
            border-bottom: 1px solid #3e3e42;
        }

        /* Consistent Entry Structure */
        .repl-entry {
            margin-bottom: 16px;
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Input Lines */
        .repl-input-line {
            display: flex;
            align-items: flex-start;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .repl-prompt {
            color: #569cd6;
            font-weight: 600;
            margin-right: 8px;
            user-select: none;
            flex-shrink: 0;
        }

        .repl-prompt.continuation {
            color: #808080;
        }

        /* Code Display with Syntax Highlighting */
        .repl-code {
            flex: 1;
            position: relative;
        }

        /* Prism.js override for inline display */
        .repl-code pre[class*="language-"] {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: visible;
        }

        .repl-code code[class*="language-"] {
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            text-shadow: none;
        }

        /* Output Styles */
        .repl-output {
            margin-left: 32px;
            color: #cccccc;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 4px;
        }

        /* Error Styles */
        .repl-error {
            margin-left: 32px;
            margin-top: 4px;
            padding: 8px 12px;
            background: rgba(244, 67, 54, 0.1);
            border-left: 3px solid #f44336;
            color: #f48771;
            white-space: pre-wrap;
            font-size: 13px;
            border-radius: 0 4px 4px 0;
        }

        .repl-error .error-type {
            color: #ff6b6b;
            font-weight: 600;
        }

        .repl-error .error-line {
            background: rgba(244, 67, 54, 0.2);
            display: inline-block;
            padding: 0 4px;
            border-radius: 2px;
            margin: 4px 0;
        }

        /* Syntax Error Highlight */
        .syntax-error-location {
            background: rgba(255, 0, 0, 0.3);
            padding: 2px 4px;
            border-radius: 2px;
            position: relative;
        }

        .syntax-error-pointer {
            color: #ff6b6b;
            font-weight: bold;
        }

        /* Input Area */
        .repl-input-area {
            padding: 20px;
            background: #252526;
        }

        .input-wrapper {
            position: relative;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            overflow: hidden;
            background: #1e1e1e;
        }

        .input-prompt-indicator {
            position: absolute;
            left: 10px;
            top: 10px;
            color: #569cd6;
            font-weight: 600;
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
        }

        .CodeMirror {
            height: auto;
            min-height: 80px;
            max-height: 200px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 14px;
            padding-left: 40px !important;
        }

        .CodeMirror-scroll {
            min-height: 80px;
            max-height: 200px;
        }

        /* Execute Button */
        .execute-btn {
            margin-top: 12px;
            padding: 10px 20px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .execute-btn:hover {
            background: #1177bb;
        }

        .execute-btn:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }

        /* Loading State */
        .repl-loading {
            margin-left: 32px;
            color: #808080;
            font-style: italic;
        }

        .loading-dots::after {
            content: '';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Scrollbar Styling */
        .repl-history::-webkit-scrollbar {
            width: 10px;
        }

        .repl-history::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        .repl-history::-webkit-scrollbar-thumb {
            background: #3e3e42;
            border-radius: 5px;
        }

        .repl-history::-webkit-scrollbar-thumb:hover {
            background: #4e4e52;
        }
    </style>
</head>
<body>
    <div id="app">
        <python-repl></python-repl>
    </div>

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <script>
        const { createApp } = Vue;

        // Vue Component for REPL
        const PythonREPL = {
            template: `
                <div class="repl-container">
                    <div class="repl-header">
                        <h2>Python Interactive Shell</h2>
                    </div>
                    
                    <div class="repl-history" ref="historyContainer">
                        <div v-for="entry in history" :key="entry.id" class="repl-entry">
                            <!-- Input Lines -->
                            <div v-for="(line, index) in entry.input" :key="'input-' + index" class="repl-input-line">
                                <span class="repl-prompt" :class="{ continuation: index > 0 }">
                                    {{ index === 0 ? '>>>' : '...' }}
                                </span>
                                <div class="repl-code" v-html="highlightCode(line)"></div>
                            </div>
                            
                            <!-- Output -->
                            <div v-if="entry.output" class="repl-output">{{ entry.output }}</div>
                            
                            <!-- Error -->
                            <div v-if="entry.error" class="repl-error" v-html="formatError(entry.error)"></div>
                            
                            <!-- Loading -->
                            <div v-if="entry.loading" class="repl-loading">
                                <span class="loading-dots">Executing</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="repl-input-area">
                        <div class="input-wrapper">
                            <div class="input-prompt-indicator">{{ currentPrompt }}</div>
                            <textarea ref="inputArea" id="code-input"></textarea>
                        </div>
                        <button 
                            @click="executeCode" 
                            :disabled="executing"
                            class="execute-btn"
                        >
                            {{ executing ? 'Executing...' : 'Run (Shift+Enter)' }}
                        </button>
                    </div>
                </div>
            `,
            
            data() {
                return {
                    history: [],
                    currentCode: '',
                    multilineBuffer: [],
                    isMultiline: false,
                    executing: false,
                    entryIdCounter: 0,
                    codeMirror: null,
                    currentPrompt: '>>>'
                };
            },
            
            mounted() {
                this.initializeCodeMirror();
                this.addExampleEntry();
            },
            
            methods: {
                initializeCodeMirror() {
                    this.codeMirror = CodeMirror.fromTextArea(this.$refs.inputArea, {
                        mode: 'python',
                        theme: 'monokai',
                        lineNumbers: false,
                        autoCloseBrackets: true,
                        indentUnit: 4,
                        lineWrapping: true,
                        extraKeys: {
                            'Shift-Enter': () => this.executeCode(),
                            'Tab': (cm) => {
                                const spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
                                cm.replaceSelection(spaces);
                            }
                        }
                    });
                },
                
                highlightCode(code) {
                    // Use Prism.js for syntax highlighting
                    const highlighted = Prism.highlight(code, Prism.languages.python, 'python');
                    return `<pre class="language-python"><code class="language-python">${highlighted}</code></pre>`;
                },
                
                formatError(error) {
                    // Parse and format Python errors
                    const lines = error.split('\n');
                    let formatted = '';
                    
                    for (let line of lines) {
                        if (line.includes('SyntaxError:')) {
                            formatted += `<span class="error-type">SyntaxError:</span> ${line.replace('SyntaxError:', '')}`;
                        } else if (line.includes('NameError:')) {
                            formatted += `<span class="error-type">NameError:</span> ${line.replace('NameError:', '')}`;
                        } else if (line.includes('TypeError:')) {
                            formatted += `<span class="error-type">TypeError:</span> ${line.replace('TypeError:', '')}`;
                        } else if (line.includes('IndentationError:')) {
                            formatted += `<span class="error-type">IndentationError:</span> ${line.replace('IndentationError:', '')}`;
                        } else if (line.match(/^\s*\^+\s*$/)) {
                            formatted += `<span class="syntax-error-pointer">${line}</span>`;
                        } else if (line.match(/File .*, line \d+/)) {
                            formatted += `<span style="color: #808080;">${line}</span>`;
                        } else {
                            formatted += line;
                        }
                        formatted += '\n';
                    }
                    
                    return formatted;
                },
                
                async executeCode() {
                    if (this.executing) return;
                    
                    const code = this.codeMirror.getValue();
                    if (!code.trim()) return;
                    
                    // Add to multiline buffer if in multiline mode
                    if (this.isMultiline) {
                        this.multilineBuffer.push(code);
                    } else {
                        this.multilineBuffer = [code];
                    }
                    
                    // Create entry
                    const entry = {
                        id: ++this.entryIdCounter,
                        input: this.multilineBuffer.slice(),
                        output: null,
                        error: null,
                        loading: true
                    };
                    
                    this.history.push(entry);
                    this.executing = true;
                    
                    // Clear input
                    this.codeMirror.setValue('');
                    
                    // Scroll to bottom
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                    
                    try {
                        // Simulate API call to Python backend
                        const response = await this.executePythonCode(this.multilineBuffer.join('\n'));
                        
                        entry.loading = false;
                        
                        if (response.error) {
                            entry.error = response.error;
                            this.isMultiline = false;
                            this.multilineBuffer = [];
                            this.currentPrompt = '>>>';
                        } else if (response.incomplete) {
                            // Need more input
                            this.isMultiline = true;
                            this.currentPrompt = '...';
                            // Remove loading state for incomplete entries
                            entry.loading = false;
                        } else {
                            // Success
                            entry.output = response.output;
                            this.isMultiline = false;
                            this.multilineBuffer = [];
                            this.currentPrompt = '>>>';
                        }
                        
                    } catch (error) {
                        entry.loading = false;
                        entry.error = `Error: ${error.message}`;
                        this.isMultiline = false;
                        this.multilineBuffer = [];
                        this.currentPrompt = '>>>';
                    } finally {
                        this.executing = false;
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                    }
                },
                
                async executePythonCode(code) {
                    // Simulate Python backend response
                    // Replace this with your actual API call
                    
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            // Check for multiline constructs
                            if (code.endsWith(':') || code.split('\n').pop().startsWith('    ')) {
                                resolve({ incomplete: true });
                                return;
                            }
                            
                            // Simulate various responses
                            if (code.includes('syntax error')) {
                                resolve({
                                    error: `  File "<stdin>", line 1\n    ${code}\n    ${''.padStart(code.indexOf('syntax'), ' ')}^\nSyntaxError: invalid syntax`
                                });
                            } else if (code.includes('print')) {
                                const match = code.match(/print\((.*?)\)/);
                                if (match) {
                                    const content = match[1].replace(/['"]/g, '');
                                    resolve({ output: content });
                                } else {
                                    resolve({ output: 'None' });
                                }
                            } else if (code.includes('def ') || code.includes('class ')) {
                                resolve({ output: '' });
                            } else if (code.includes('for ') && code.includes('range')) {
                                resolve({ output: '0\n1\n2\n3' });
                            } else {
                                resolve({ output: 'None' });
                            }
                        }, 500);
                    });
                },
                
                scrollToBottom() {
                    const container = this.$refs.historyContainer;
                    container.scrollTop = container.scrollHeight;
                },
                
                addExampleEntry() {
                    // Add an example entry to show the styling
                    this.history.push({
                        id: ++this.entryIdCounter,
                        input: ['for i in range(4):', '    print(i)'],
                        output: '0\n1\n2\n3',
                        error: null,
                        loading: false
                    });
                }
            }
        };

        // Create Vue app
        createApp({
            components: {
                'python-repl': PythonREPL
            }
        }).mount('#app');
    </script>
</body>
</html>