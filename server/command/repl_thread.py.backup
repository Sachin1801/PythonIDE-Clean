#!/usr/bin/env python3
"""
True Python REPL implementation for interactive code execution.
Supports multi-line statements like loops, functions, and classes.
"""

import subprocess
import threading
import time
import os
import asyncio
import select
import fcntl
import sys
from queue import Queue, Empty
import code
import io
import contextlib

from common.config import Config
from command.response import response

class PythonREPLThread(threading.Thread):
    """Python REPL thread for interactive code execution"""
    
    def __init__(self, cmd_id, client, event_loop):
        super().__init__()
        self.cmd_id = cmd_id
        self.client = client
        self.event_loop = event_loop
        self.alive = True
        self.p = None
        self.input_queue = Queue()
        self.repl_locals = {}
        self.buffer = []  # For multi-line input
        self.in_multiline = False
        self.indent_level = 0
        
    def kill(self):
        """Kill the REPL session"""
        self.alive = False
        if self.p:
            try:
                self.p.kill()
            except:
                pass
    
    def stop(self):
        """Stop the REPL session gracefully"""
        self.alive = False
        if self.p:
            try:
                self.p.terminate()
            except:
                pass
    
    def send_input(self, user_input):
        """Queue user input to be processed"""
        self.input_queue.put(user_input)
        return True
    
    def response_to_client(self, code, data):
        """Send response to client via WebSocket"""
        if data:
            asyncio.run_coroutine_threadsafe(
                response(self.client, self.cmd_id, code, data),
                self.event_loop
            )
    
    def run_repl(self):
        """Run the Python REPL"""
        asyncio.set_event_loop(self.event_loop)
        
        print(f'[{self.client.id}-REPL {self.cmd_id} starting]')
        
        # Don't send welcome message - Python will send its own
        
        # Create Python subprocess with interactive mode
        try:
            self.p = subprocess.Popen(
                [Config.PYTHON, '-i', '-u'],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=0,
                env={**os.environ, 'PYTHONUNBUFFERED': '1'}
            )
            
            # Make stdout non-blocking
            fd = self.p.stdout.fileno()
            fl = fcntl.fcntl(fd, fcntl.F_GETFL)
            fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
            
            output_buffer = ""
            continuation_mode = False
            
            # Wait a bit for Python to start and send its banner
            time.sleep(0.1)
            
            while self.alive and self.p.poll() is None:
                # Check client connection
                if not self.client.connected:
                    self.alive = False
                    self.p.kill()
                    self.client.handler_info.remove_subprogram(self.cmd_id)
                    return
                
                # Check for user input
                try:
                    user_input = self.input_queue.get(timeout=0.01)
                    
                    # Send input to Python process
                    self.p.stdin.write(user_input + '\n')
                    self.p.stdin.flush()
                    
                    # Don't echo the input here - let Python echo it
                    # This way we get the proper output from Python
                    
                    # Check if we're entering continuation mode
                    stripped = user_input.strip()
                    if stripped.endswith(':') or stripped in ['def', 'class', 'if', 'elif', 'else', 'for', 'while', 'try', 'except', 'finally', 'with']:
                        continuation_mode = True
                    elif not stripped and continuation_mode:
                        # Empty line in continuation mode means end of block
                        continuation_mode = False
                    
                except Empty:
                    pass
                
                # Check for output from Python process
                try:
                    readable, _, _ = select.select([self.p.stdout], [], [], 0.01)
                    
                    if readable:
                        try:
                            # Read available data
                            chunk = self.p.stdout.read(4096)
                            if chunk:
                                output_buffer += chunk
                                
                                # Check if we have a complete prompt at the end
                                if output_buffer.endswith('>>> ') or output_buffer.endswith('... '):
                                    # Extract the prompt
                                    if output_buffer.endswith('>>> '):
                                        prompt = '>>> '
                                        continuation_mode = False
                                    else:
                                        prompt = '... '
                                        continuation_mode = True
                                    
                                    # Send everything except the prompt
                                    output_to_send = output_buffer[:-4]
                                    if output_to_send:
                                        # Send the output in chunks by lines if it has newlines
                                        lines = output_to_send.split('\n')
                                        for i, line in enumerate(lines):
                                            if i < len(lines) - 1:
                                                # Add newline back except for last line
                                                self.response_to_client(0, {'stdout': line + '\n'})
                                            elif line:  # Last line, only send if not empty
                                                self.response_to_client(0, {'stdout': line})
                                    
                                    # Send prompt request
                                    self.response_to_client(2000, {
                                        'type': 'repl_prompt',
                                        'prompt': prompt
                                    })
                                    
                                    # Clear buffer
                                    output_buffer = ""
                                    
                        except (OSError, IOError) as e:
                            if e.errno != 11:  # Ignore EAGAIN
                                raise
                except Exception as e:
                    if self.alive:  # Only log if not shutting down
                        print(f"Error reading output: {e}")
            
            # Send exit message
            self.response_to_client(1111, {'stdout': '\n[REPL session ended]'})
            
        except Exception as e:
            error_msg = f"Error in REPL: {str(e)}"
            print(f"[ERROR] {error_msg}")
            import traceback
            traceback.print_exc()
            self.response_to_client(1111, {'stdout': error_msg})
        
        finally:
            # Cleanup
            if self.p:
                try:
                    self.p.terminate()
                except:
                    pass
            
            self.client.handler_info.remove_subprogram(self.cmd_id)
            print(f'[{self.client.id}-REPL {self.cmd_id} finished]')
    
    def run(self):
        """Thread entry point"""
        self.run_repl()